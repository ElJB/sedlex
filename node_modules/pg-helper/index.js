var pg = require('pg'),
    Q = require('q'),
    debug = require('./utils.js').debug,
    log = require('./utils.js').log,
    Cursor = require('pg-cursor'),
    randomString = require('./utils.js').randomString,
    assert = require('assert');

var pgHelper = function(dbConnect){
  this.dbConnect = dbConnect,
  this.Contract = require('./contract.js');
};

/*
Promise implementation of pg.query
Include client pooling
*/

pgHelper.prototype.queryPromise = function(queryString){
  var self = this;
  return Q.promise(function(resolve, reject, notify){
    pg.connect(self.dbConnect, function(err, client, done){
      if( err ){ return reject(err) }
      debug(queryString);
      var q = client.query(queryString)
      q.on("error", function(err){
        reject(err);
        done(client);
      });
      q.on("row", function(row, result) {
        result.addRow(row);
      });
      q.on("end", function(result){
        resolve(result);
        done(client);
      });
    });
  });
}

/*
Utility function to chain query promise
*/

pgHelper.prototype.chainQueryPromise = function(queryBuilder){
  var self = this;
  return function(result){
    var queryString = typeof(queryBuilder) == "string" ? queryBuilder : queryBuilder(result);
    return self.queryPromise(queryString);
  }
}

/*
Promise implementation of Cursor
*/

pgHelper.prototype.Cursor = function(queryString){

  //TO DO: refactor to allow for parameterized query
  var self = this;
  this.cursor = Q.promise(function(resolve, reject, notify){
    pg.connect(self.dbConnect, function(err, client, done){
      if( err ){ return reject(err) }
      var cursor = client.query(new Cursor(queryString));
      resolve(cursor);
      self.cursor.close = function(){
        cursor.close();
        done();
      };
    });
  });
  this.cursor.catch(log);
}

pgHelper.prototype.Cursor.prototype.next = function(n){
  var self = this;
  if( !n ){ n = 1 }

  return Q.promise(function(resolve, reject, notify){
    self.cursor.then(function(cursor){
      cursor.read(n, function(err, rows){
        if(err){ 
          return reject(err);
          done();
        }
        resolve(rows);
      });
    });
  });
}

pgHelper.prototype.Cursor.prototype.whileNext = function(n, callback){
  if( typeof(n) == "function" ){
    callback = n;
    n = 1;
  }

  //TO DO: refactor with an event emitter

  var self = this;
  return Q.promise(function(resolve, reject, notify){

    var nextBatch = function(n, callback){
      self.next().then(function(rows){
        if( rows.length == 0){
          resolve();
          return;
        }
        callback(rows);
        nextBatch(n, callback);
      }).catch(reject);
    }

    nextBatch(n, callback);
  });
}

pgHelper.prototype.Cursor.prototype.close = function(){
  this.cursor.close();
}

/*
Transaction utility functions
*/

pgHelper.prototype.startTransaction = function(queryString){
  if( !queryString ){ queryString = "BEGIN" }
  var self = this;

  return Q.promise(function(resolve, reject, notify){
    pg.connect(self.dbConnect, function(err, client, done){
      if( err ){ return reject(err) }
      var q = client.query(queryString)
      q.on("error", function(err){
        reject(err);
        done(client);
      });
      q.on("row", function(row, result) {
        result.addRow(row);
      });
      q.on("end", function(result){
        debug(queryString.substring(0, 100));
        resolve([result, client]);
      });
    });
  });
}

var rollback = function(client) {
  debug("ROLLBACK");
  client.query("ROLLBACK", function() {
    client.end();
  });
};

pgHelper.prototype.tQueryPromise = function(queryString){
  return function(args){
    var result = args[0],
        client = args[1];

    return Q.promise(function(resolve, reject, notify){
      debug(queryString);
      
      var q = client.query(queryString)
      q.on("error", function(err){
        reject(err);
        rollback(client);
      });
      q.on("row", function(row, result) {
        result.addRow(row);
      });
      q.on("end", function(result){
        resolve([result, client]);
      });
    });

  }
}

pgHelper.prototype.closeTransaction = function(args){
  var result = args[0],
      client = args[1];

  return Q.promise(function(resolve, reject, notify){
    debug("COMMIT");
    var q = client.query("COMMIT")
    q.on("error", function(err){
      reject(err);
      rollback(client);
    });
    q.on("row", function(row, result) {
      result.addRow(row);
    });
    q.on("end", function(result){
      resolve(result);
      client.end();
    });
  });
}


pgHelper.prototype.buildSQLInsertString = function(tableName, columns, data){
  assert(columns);
  var result = "INSERT into " + tableName;
  if( columns ){
    result += " (";
    for( c in columns ){
      result += columns[c] + ", ";
    }
    result = result.substring(0, result.length - 2) + ")"
  }
  result += " VALUES (";
  for( d in data ){
    result += data[d] + ", "
  }
  return result.substring(0, result.length - 2) + ");";
}

pgHelper.prototype.getTables = function(){
  return this.queryPromise("SELECT table_name FROM information_schema.tables " +
  "WHERE table_schema='public' AND table_type='BASE TABLE';");
}

pgHelper.prototype.quotify = function(s){
  return "'" + s + "'";
}

pgHelper.prototype.dollarize = function(s){
  var tag = "$" + randomString(5) + "$";
  return tag + s + tag;
}

module.exports = pgHelper;
    

